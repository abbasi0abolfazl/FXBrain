"""
FastAPI application for FX Brain - A trading analysis platform providing news analysis,
economic calendar, trading signals, smart alerts, and personalized dashboard.
"""

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any
from pydantic import BaseModel
from enum import Enum
import jwt
import random

# ============================================================================
# Configuration
# ============================================================================

SECRET_KEY = "your-secret-key-here-change-in-production"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

app = FastAPI(
    title="FX Brain API",
    description="API for trading analysis platform"
)

# CORS middleware configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ============================================================================
# Pydantic Models
# ============================================================================

class User(BaseModel):
    """User model for authentication and profile management."""
    id: int
    email: str
    name: str
    role: str  # admin, pro, demo
    is_active: bool
    created_at: str


class LoginRequest(BaseModel):
    """Login request model."""
    email: str
    password: str


class LoginResponse(BaseModel):
    """Login response model with JWT token."""
    token: str
    user: User
    message: str


class NewsArticle(BaseModel):
    """News article model with AI-powered analysis."""
    id: int
    title: str
    summary: str
    source: str
    published_at: str
    category: str
    impact_level: str  # high, medium, low
    sentiment: str  # positive, neutral, negative
    prediction: str  # e.g., "bullish GBP" or "bearish JPY"
    affected_currencies: List[str]


class EconomicEvent(BaseModel):
    """Economic calendar event model."""
    id: int
    event_time: str
    country: str
    event_name: str
    importance: str
    forecast: str
    previous: str
    actual: Optional[str] = None
    # Additional fields for UI compatibility
    forecast_value: Optional[str] = None
    previous_value: Optional[str] = None
    actual_value: Optional[str] = None


class TradingSignal(BaseModel):
    """Trading signal model generated by AI analysis."""
    id: int
    signal_type: str  # buy, sell
    pair: str
    entry_price: float
    stop_loss: float
    take_profit: float
    confidence: int  # 0-100
    status: str  # active, hit_tp, hit_sl, pending
    created_at: str
    analysis: str
    reasons: List[str]


class UserAlert(BaseModel):
    """Smart alert model for price and news notifications."""
    id: int
    name: str
    currency_pair: str
    condition_type: str  # price_above, price_below, rsi_above, rsi_below, news_high_impact
    condition_value: Optional[float] = None
    notification_channels: List[str]  # web, telegram, email
    is_active: bool
    triggered_at: Optional[str] = None
    created_at: str
    user_id: int = 1  # Default user for samples


class DashboardWidget(BaseModel):
    """Dashboard widget configuration model."""
    id: str
    type: str  # signals, news, calendar, alerts, chart
    title: str
    icon: str  # Zap, Newspaper, Calendar, Bell, LineChart
    default_order: int
    min_height: Optional[int] = 300
    config: Optional[Dict] = None


class UserDashboard(BaseModel):
    """User dashboard layout and configuration model."""
    id: int
    user_id: int
    widgets: List[Dict]  # [{"id": "signals", "order": 0, "config": {}}]
    created_at: str
    updated_at: str


# ============================================================================
# Sample Data Generator
# ============================================================================

class SampleData:
    """
    Container class for all sample data used in the application.
    Provides methods to generate realistic sample data for development and testing.
    """
    
    def __init__(self):
        """Initialize sample data generator with current timestamp."""
        self.now = datetime.now()
        self.users = self._generate_users()
        self.news = self._generate_news()
        self.events = self._generate_events()
        self.signals = self._generate_signals()
        self.alerts = self._generate_alerts()
        self.widgets = self._generate_widgets()
        self.dashboards = self._generate_dashboards()
    
    def _generate_users(self) -> List[Dict]:
        """
        Generate sample user data for authentication testing.
        
        Returns:
            List[Dict]: List of user objects with credentials
        """
        return [
            {
                "id": 1,
                "email": "demo@example.com",
                "password": "demo123",  # In production, this should be hashed
                "name": "Ú©Ø§Ø±Ø¨Ø± Ø¯Ù…Ùˆ",
                "role": "demo",
                "is_active": True,
                "created_at": "2024-01-01T00:00:00Z"
            },
            {
                "id": 2,
                "email": "pro@example.com",
                "password": "pro123",
                "name": "Ú©Ø§Ø±Ø¨Ø± Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ",
                "role": "pro",
                "is_active": True,
                "created_at": "2024-01-01T00:00:00Z"
            },
            {
                "id": 3,
                "email": "admin@example.com",
                "password": "admin123",
                "name": "Ù…Ø¯ÛŒØ± Ø³ÛŒØ³ØªÙ…",
                "role": "admin",
                "is_active": True,
                "created_at": "2024-01-01T00:00:00Z"
            }
        ]
    
    def _generate_news(self) -> List[Dict]:
        """
        Generate sample news articles with AI-powered analysis.
        
        Returns:
            List[Dict]: List of news articles with predictions and impact levels
        """
        return [
            {
                "id": 1,
                "title": "Ø¨Ø§Ù†Ú© Ù…Ø±Ú©Ø²ÛŒ Ø§Ø±ÙˆÙ¾Ø§ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ø±Ø§ Ø¯Ø± Û´Ùª Ø«Ø§Ø¨Øª Ù†Ú¯Ù‡ Ø¯Ø§Ø´Øª",
                "summary": "Ø¨Ø§Ù†Ú© Ù…Ø±Ú©Ø²ÛŒ Ø§Ø±ÙˆÙ¾Ø§ Ø¯Ø± Ø¢Ø®Ø±ÛŒÙ† Ø¬Ù„Ø³Ù‡ Ø®ÙˆØ¯ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ø±Ø§ Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ± Ø¯Ø± Û´Ùª Ù†Ú¯Ù‡ Ø¯Ø§Ø´Øª. Ø§ÛŒÙ† ØªØµÙ…ÛŒÙ… Ù…Ø·Ø§Ø¨Ù‚ Ø§Ù†ØªØ¸Ø§Ø±Ø§Øª Ø¨Ø§Ø²Ø§Ø± Ø¨ÙˆØ¯.",
                "source": "Bloomberg",
                "published_at": "2024-02-06T19:30:00Z",
                "category": "Ø§Ù‚ØªØµØ§Ø¯ÛŒ",
                "impact_level": "high",
                "sentiment": "neutral",
                "prediction": "bullish EUR",
                "affected_currencies": ["EUR/USD", "EUR/GBP", "EUR/JPY"],
            },
            {
                "id": 2,
                "title": "Ø§Ø¯Ø§Ù…Ù‡ Ø±Ø´Ø¯ Ø´Ø§Ø®Øµ S&P 500 Ø¨Ù‡ Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ø³Ø·Ø­ Ø³Ù‡ Ù…Ø§Ù‡Ù‡",
                "summary": "Ø´Ø§Ø®Øµ S&P 500 Ø¨Ø±Ø§ÛŒ Ø³ÙˆÙ…ÛŒÙ† Ø±ÙˆØ² Ù…ØªÙˆØ§Ù„ÛŒ Ø±Ø´Ø¯ Ú©Ø±Ø¯Ù‡ Ùˆ Ø¨Ù‡ Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ø³Ø·Ø­ Ø³Ù‡ Ù…Ø§Ù‡Ù‡ Ø±Ø³ÛŒØ¯. Ø§ÛŒÙ† Ø±Ø´Ø¯ Ù†Ø´Ø§Ù†â€ŒØ¯Ù‡Ù†Ø¯Ù‡ Ø¨Ù‡Ø¨ÙˆØ¯ Ø±ÛŒØ³Ú©â€ŒÙ¾Ø°ÛŒØ±ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø§Ø³Øª.",
                "source": "Reuters",
                "published_at": "2024-02-06T18:45:00Z",
                "category": "Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ",
                "impact_level": "medium",
                "sentiment": "positive",
                "prediction": "bearish JPY",
                "affected_currencies": ["USD/JPY", "AUD/JPY", "EUR/JPY"],
            },
            {
                "id": 3,
                "title": "Ø§ÙØ²Ø§ÛŒØ´ Û²Ùª Ø¨Ù‡Ø§ÛŒ Ù†ÙØª Ø¨Ù‡ Ø¯Ù„ÛŒÙ„ ØªÙ†Ø´â€ŒÙ‡Ø§ÛŒ Ø®Ø§ÙˆØ±Ù…ÛŒØ§Ù†Ù‡",
                "summary": "Ø¨Ù‡Ø§ÛŒ Ù†ÙØª Ø®Ø§Ù… Ø¨Ø±Ù†Øª Ø¨Ø§ Ø§ÙØ²Ø§ÛŒØ´ Û² Ø¯Ø±ØµØ¯ÛŒ Ø¨Ù‡ Û¸Ûµ Ø¯Ù„Ø§Ø± Ø¯Ø± Ù‡Ø± Ø¨Ø´Ú©Ù‡ Ø±Ø³ÛŒØ¯. Ø§ÛŒÙ† Ø§ÙØ²Ø§ÛŒØ´ Ù†Ø§Ø´ÛŒ Ø§Ø² Ù†Ú¯Ø±Ø§Ù†ÛŒâ€ŒÙ‡Ø§ Ø¯Ø±Ø¨Ø§Ø±Ù‡ Ø§Ø®ØªÙ„Ø§Ù„ Ø¯Ø± Ø¹Ø±Ø¶Ù‡ Ù†ÙØª Ø§Ø² Ù…Ù†Ø·Ù‚Ù‡ Ø®Ø§ÙˆØ±Ù…ÛŒØ§Ù†Ù‡ Ø§Ø³Øª.",
                "source": "CNBC",
                "published_at": "2024-02-06T17:15:00Z",
                "category": "Ú©Ø§Ù„Ø§Ù‡Ø§",
                "impact_level": "high",
                "sentiment": "negative",
                "prediction": "bullish CAD",
                "affected_currencies": ["USD/CAD", "CAD/JPY", "EUR/CAD"],
            },
            {
                "id": 4,
                "title": "ØªÙˆØ±Ù… Ø§Ù†Ú¯Ù„ÛŒØ³ Ú©Ù…ØªØ± Ø§Ø² Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø¨Ù‡ Û³.Û¹Ùª Ú©Ø§Ù‡Ø´ ÛŒØ§ÙØª",
                "summary": "Ù†Ø±Ø® ØªÙˆØ±Ù… Ø§Ù†Ú¯Ù„ÛŒØ³ Ø¯Ø± Ù…Ø§Ù‡ Ú¯Ø°Ø´ØªÙ‡ Ø¨Ù‡ Û³.Û¹Ùª Ú©Ø§Ù‡Ø´ ÛŒØ§ÙØª Ú©Ù‡ Ú©Ù…ØªØ± Ø§Ø² Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Û´.Û²Ùª Ø¨ÙˆØ¯ Ùˆ Ù†Ø´Ø§Ù†Ù‡â€ŒØ§ÛŒ Ø§Ø² Ú©Ø§Ù‡Ø´ ÙØ´Ø§Ø±Ù‡Ø§ÛŒ Ù‚ÛŒÙ…ØªÛŒ Ø§Ø³Øª.",
                "source": "Financial Times",
                "published_at": "2024-02-06T16:30:00Z",
                "category": "Ø§Ù‚ØªØµØ§Ø¯ÛŒ",
                "impact_level": "high",
                "sentiment": "positive",
                "prediction": "bullish GBP",
                "affected_currencies": ["GBP/USD", "EUR/GBP", "GBP/JPY"],
            },
            {
                "id": 5,
                "title": "ØªØ§Ú©ÛŒØ¯ Ø¨Ø§Ù†Ú© Ú˜Ø§Ù¾Ù† Ø¨Ø± Ø§Ø¯Ø§Ù…Ù‡ Ø³ÛŒØ§Ø³Øª Ù¾ÙˆÙ„ÛŒ Ø§Ù†Ø¨Ø³Ø§Ø·ÛŒ",
                "summary": "Ø¨Ø§Ù†Ú© Ú˜Ø§Ù¾Ù† Ø¨Ø± Ø§Ø¯Ø§Ù…Ù‡ Ø³ÛŒØ§Ø³Øª Ù¾ÙˆÙ„ÛŒ Ø§Ù†Ø¨Ø³Ø§Ø·ÛŒ Ø®ÙˆØ¯ ØªØ£Ú©ÛŒØ¯ Ú©Ø±Ø¯ Ùˆ Ø§Ø­ØªÙ…Ø§Ù„ ØªØºÛŒÛŒØ± Ø¯Ø± Ø³ÛŒØ§Ø³Øªâ€ŒÙ‡Ø§ Ø±Ø§ Ø¯Ø± Ú©ÙˆØªØ§Ù‡â€ŒÙ…Ø¯Øª Ø±Ø¯ Ú©Ø±Ø¯.",
                "source": "Nikkei",
                "published_at": "2024-02-06T15:45:00Z",
                "category": "Ø§Ù‚ØªØµØ§Ø¯ÛŒ",
                "impact_level": "medium",
                "sentiment": "negative",
                "prediction": "bearish JPY",
                "affected_currencies": ["USD/JPY", "EUR/JPY", "GBP/JPY"],
            },
            {
                "id": 6,
                "title": "ØªÙˆÙ„ÛŒØ¯ ØµÙ†Ø¹ØªÛŒ Ø¢Ù„Ù…Ø§Ù† ÙØ±Ø§ØªØ± Ø§Ø² Ø§Ù†ØªØ¸Ø§Ø± Ø±Ø´Ø¯ Ú©Ø±Ø¯",
                "summary": "ØªÙˆÙ„ÛŒØ¯ ØµÙ†Ø¹ØªÛŒ Ø¢Ù„Ù…Ø§Ù† Ø¯Ø± Ø¯Ø³Ø§Ù…Ø¨Ø± Û°.Û¸Ùª Ø±Ø´Ø¯ Ú©Ø±Ø¯ Ú©Ù‡ Ø¨Ù‡ØªØ± Ø§Ø² Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Û°.Û³Ùª Ø¨ÙˆØ¯ Ùˆ Ù†Ø´Ø§Ù†Ù‡â€ŒØ§ÛŒ Ø§Ø² Ø¨Ù‡Ø¨ÙˆØ¯ ÙØ¹Ø§Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ ØµÙ†Ø¹ØªÛŒ Ø§Ø³Øª.",
                "source": "DW",
                "published_at": "2024-02-06T14:20:00Z",
                "category": "Ø§Ù‚ØªØµØ§Ø¯ÛŒ",
                "impact_level": "medium",
                "sentiment": "positive",
                "prediction": "bullish EUR",
                "affected_currencies": ["EUR/USD", "EUR/CHF"],
            },
            {
                "id": 7,
                "title": "Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ø´ØªØºØ§Ù„ Ø§Ø³ØªØ±Ø§Ù„ÛŒØ§ Ù†Ø§Ø§Ù…ÛŒØ¯Ú©Ù†Ù†Ø¯Ù‡ Ø¨ÙˆØ¯",
                "summary": "Ù†Ø±Ø® Ø¨ÛŒÚ©Ø§Ø±ÛŒ Ø§Ø³ØªØ±Ø§Ù„ÛŒØ§ Ø§Ø² Û³.Û·Ùª Ø¨Ù‡ Û³.Û¹Ùª Ø§ÙØ²Ø§ÛŒØ´ ÛŒØ§ÙØª Ú©Ù‡ Ø¨Ø§Ù„Ø§ØªØ± Ø§Ø² Ø§Ù†ØªØ¸Ø§Ø±Ø§Øª Ø¨Ø§Ø²Ø§Ø± Ùˆ Ù†Ø´Ø§Ù†Ù‡â€ŒØ§ÛŒ Ø§Ø² Ø¶Ø¹Ù Ø¨Ø§Ø²Ø§Ø± Ú©Ø§Ø± Ø§Ø³Øª.",
                "source": "ABC Australia",
                "published_at": "2024-02-06T13:10:00Z",
                "category": "Ø§Ù‚ØªØµØ§Ø¯ÛŒ",
                "impact_level": "medium",
                "sentiment": "negative",
                "prediction": "bearish AUD",
                "affected_currencies": ["AUD/USD", "NZD/AUD"],
            },
            {
                "id": 8,
                "title": "ÙØ±ÙˆØ´ Ø®Ø±Ø¯Ù‡â€ŒÙØ±ÙˆØ´ÛŒ Ø¢Ù…Ø±ÛŒÚ©Ø§ Ù…Ø·Ø§Ø¨Ù‚ Ø§Ù†ØªØ¸Ø§Ø± Û°.Û¶Ùª Ø±Ø´Ø¯ Ú©Ø±Ø¯",
                "summary": "ÙØ±ÙˆØ´ Ø®Ø±Ø¯Ù‡â€ŒÙØ±ÙˆØ´ÛŒ Ø¢Ù…Ø±ÛŒÚ©Ø§ Ø¯Ø± Ù…Ø§Ù‡ Ú¯Ø°Ø´ØªÙ‡ Û°.Û¶Ùª Ø±Ø´Ø¯ Ú©Ø±Ø¯ Ú©Ù‡ Ú©Ø§Ù…Ù„Ø§Ù‹ Ù…Ø·Ø§Ø¨Ù‚ Ø¨Ø§ Ø§Ù†ØªØ¸Ø§Ø±Ø§Øª Ø¨ÙˆØ¯ Ùˆ Ù†Ø´Ø§Ù†Ù‡â€ŒØ§ÛŒ Ø§Ø² Ø«Ø¨Ø§Øª Ù‡Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ØµØ±Ùâ€ŒÚ©Ù†Ù†Ø¯Ù‡ Ø§Ø³Øª.",
                "source": "Wall Street Journal",
                "published_at": "2024-02-06T12:00:00Z",
                "category": "Ø§Ù‚ØªØµØ§Ø¯ÛŒ",
                "impact_level": "low",
                "sentiment": "neutral",
                "prediction": "neutral USD",
                "affected_currencies": ["USD/Index", "EUR/USD"],
            },
            {
                "id": 9,
                "title": "Ø±Ø´Ø¯ Û¶.Û¸Ùª ØªÙˆÙ„ÛŒØ¯ ØµÙ†Ø¹ØªÛŒ Ú†ÛŒÙ† ÙØ±Ø§ØªØ± Ø§Ø² Ø§Ù†ØªØ¸Ø§Ø±",
                "summary": "ØªÙˆÙ„ÛŒØ¯ ØµÙ†Ø¹ØªÛŒ Ú†ÛŒÙ† Ø¯Ø± Ù…Ø§Ù‡ Ú¯Ø°Ø´ØªÙ‡ Û¶.Û¸Ùª Ø±Ø´Ø¯ Ú©Ø±Ø¯ Ú©Ù‡ Ø¨Ø§Ù„Ø§ØªØ± Ø§Ø² Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ûµ.Û¹Ùª Ø¨ÙˆØ¯ Ùˆ Ù†Ø´Ø§Ù†Ù‡â€ŒØ§ÛŒ Ø§Ø² Ù‚Ø¯Ø±Øª ÙØ¹Ø§Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ÛŒ Ø§Ø³Øª.",
                "source": "Xinhua",
                "published_at": "2024-02-06T11:30:00Z",
                "category": "Ø§Ù‚ØªØµØ§Ø¯ÛŒ",
                "impact_level": "medium",
                "sentiment": "positive",
                "prediction": "bullish AUD",
                "affected_currencies": ["AUD/USD", "AUD/JPY"],
            },
            {
                "id": 10,
                "title": "Ú©Ø§Ù‡Ø´ Ø¨ÛŒØ´ Ø§Ø² Ø§Ù†ØªØ¸Ø§Ø± ØµØ§Ø¯Ø±Ø§Øª Ú©Ø§Ù†Ø§Ø¯Ø§",
                "summary": "ØµØ§Ø¯Ø±Ø§Øª Ú©Ø§Ù†Ø§Ø¯Ø§ Ø¯Ø± Ø¯Ø³Ø§Ù…Ø¨Ø± Û±.ÛµÙª Ú©Ø§Ù‡Ø´ ÛŒØ§ÙØª Ú©Ù‡ Ø¨ÛŒØ´ØªØ± Ø§Ø² Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Û°.Û¸Ùª Ø¨ÙˆØ¯ Ùˆ Ù†Ú¯Ø±Ø§Ù†ÛŒâ€ŒÙ‡Ø§ÛŒÛŒ Ø¯Ø±Ø¨Ø§Ø±Ù‡ Ø±ÙˆÙ†Ø¯ Ø§Ù‚ØªØµØ§Ø¯ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø±Ø¯.",
                "source": "CBC",
                "published_at": "2024-02-06T10:45:00Z",
                "category": "Ø§Ù‚ØªØµØ§Ø¯ÛŒ",
                "impact_level": "low",
                "sentiment": "negative",
                "prediction": "bearish CAD",
                "affected_currencies": ["USD/CAD", "CAD/CHF"],
            }
        ]
    
    def _generate_events(self) -> List[Dict]:
        """
        Generate sample economic calendar events with dynamic dates.
        
        Returns:
            List[Dict]: List of economic events for the calendar
        """
        events = []
        
        # Today's events
        events.append({
            "id": 1,
            "event_time": self.now.replace(hour=10, minute=30, second=0).isoformat() + "Z",
            "country": "USD",
            "event_name": "Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ ÙØ¯Ø±Ø§Ù„ Ø±Ø²Ø±Ùˆ",
            "importance": "high",
            "forecast": "Ûµ.ÛµÙª",
            "previous": "Ûµ.Û²ÛµÙª",
            "actual": None,
            "forecast_value": "Ûµ.ÛµÙª",
            "previous_value": "Ûµ.Û²ÛµÙª",
            "actual_value": None
        })
        
        events.append({
            "id": 2,
            "event_time": self.now.replace(hour=13, minute=0, second=0).isoformat() + "Z",
            "country": "EUR",
            "event_name": "Ø´Ø§Ø®Øµ Ù‚ÛŒÙ…Øª Ù…ØµØ±Ùâ€ŒÚ©Ù†Ù†Ø¯Ù‡ Ø¢Ù„Ù…Ø§Ù†",
            "importance": "medium",
            "forecast": "Û².Û¸Ùª",
            "previous": "Û².Û¹Ùª",
            "actual": None,
            "forecast_value": "Û².Û¸Ùª",
            "previous_value": "Û².Û¹Ùª",
            "actual_value": None
        })
        
        # Tomorrow's events
        tomorrow = self.now + timedelta(days=1)
        events.append({
            "id": 3,
            "event_time": tomorrow.replace(hour=15, minute=30, second=0).isoformat() + "Z",
            "country": "GBP",
            "event_name": "ØªÙˆÙ„ÛŒØ¯ Ù†Ø§Ø®Ø§Ù„Øµ Ø¯Ø§Ø®Ù„ÛŒ",
            "importance": "medium",
            "forecast": "Û°.Û³Ùª",
            "previous": "Û°.Û²Ùª",
            "actual": None,
            "forecast_value": "Û°.Û³Ùª",
            "previous_value": "Û°.Û²Ùª",
            "actual_value": None
        })
        
        # Day after tomorrow
        day_after = self.now + timedelta(days=2)
        events.append({
            "id": 4,
            "event_time": day_after.replace(hour=8, minute=0, second=0).isoformat() + "Z",
            "country": "JPY",
            "event_name": "ØªØ±Ø§Ø² ØªØ¬Ø§Ø±ÛŒ",
            "importance": "low",
            "forecast": "Û°.Ûµ ØªØ±ÛŒÙ„ÛŒÙˆÙ† ÛŒÙ†",
            "previous": "Û°.Û³ ØªØ±ÛŒÙ„ÛŒÙˆÙ† ÛŒÙ†",
            "actual": None,
            "forecast_value": "Û°.Ûµ ØªØ±ÛŒÙ„ÛŒÙˆÙ† ÛŒÙ†",
            "previous_value": "Û°.Û³ ØªØ±ÛŒÙ„ÛŒÙˆÙ† ÛŒÙ†",
            "actual_value": None
        })
        
        return events
    
    def _generate_signals(self) -> List[Dict]:
        """
        Generate sample trading signals with various statuses.
        
        Returns:
            List[Dict]: List of trading signals including active and historical ones
        """
        signals = []
        yesterday = self.now - timedelta(days=1)
        
        # Active signals
        signals.extend([
            {
                "id": 1,
                "signal_type": "buy",
                "pair": "EUR/USD",
                "entry_price": 1.0875,
                "stop_loss": 1.0825,
                "take_profit": 1.0950,
                "confidence": 85,
                "status": "active",
                "created_at": self.now.isoformat() + "Z",
                "analysis": "ØªØ¶Ø¹ÛŒÙ Ø¯Ù„Ø§Ø± Ø¢Ù…Ø±ÛŒÚ©Ø§ Ù¾Ø³ Ø§Ø² Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¶Ø¹ÛŒÙ Ø§Ø´ØªØºØ§Ù„",
                "reasons": [
                    "CPI Ú©Ù…ØªØ± Ø§Ø² Ø§Ù†ØªØ¸Ø§Ø±",
                    "ØªÙ†Ø´â€ŒÙ‡Ø§ÛŒ Ú˜Ø¦ÙˆÙ¾Ù„ÛŒØªÛŒÚ©",
                    "Ø­Ù…Ø§ÛŒØª Ù‚ÙˆÛŒ Ø¯Ø± Û±.Û°Û¸ÛµÛ°"
                ]
            },
            {
                "id": 2,
                "signal_type": "sell",
                "pair": "GBP/USD",
                "entry_price": 1.2650,
                "stop_loss": 1.2710,
                "take_profit": 1.2550,
                "confidence": 75,
                "status": "active",
                "created_at": self.now.isoformat() + "Z",
                "analysis": "ÙØ´Ø§Ø± Ù†Ø²ÙˆÙ„ÛŒ Ø¨Ù‡ Ø¯Ù„ÛŒÙ„ Ù†Ú¯Ø±Ø§Ù†ÛŒ Ø§Ø² ØªÙˆØ±Ù… Ø¯Ø± Ø§Ù†Ú¯Ù„ÛŒØ³",
                "reasons": [
                    "Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ PMI Ø¶Ø¹ÛŒÙ",
                    "Ù…Ù‚Ø§ÙˆÙ…Øª Ù‚ÙˆÛŒ Ø¯Ø± Û±.Û²Û¶Û¸Û°",
                    "Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯"
                ]
            },
            {
                "id": 3,
                "signal_type": "buy",
                "pair": "USD/JPY",
                "entry_price": 149.25,
                "stop_loss": 148.70,
                "take_profit": 150.30,
                "confidence": 90,
                "status": "active",
                "created_at": self.now.isoformat() + "Z",
                "analysis": "Ø§ÙØ²Ø§ÛŒØ´ Ø¨Ø§Ø²Ø¯Ù‡ÛŒ Ø§ÙˆØ±Ø§Ù‚ Ø®Ø²Ø§Ù†Ù‡ Ø¢Ù…Ø±ÛŒÚ©Ø§",
                "reasons": [
                    "Ø§Ø®ØªÙ„Ø§Ù Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡",
                    "Ø±ÙˆÙ†Ø¯ ØµØ¹ÙˆØ¯ÛŒ Ù‚ÙˆÛŒ",
                    "Ø³ÛŒØ§Ø³Øª Ø§Ù†Ø¨Ø³Ø§Ø·ÛŒ Ø¨Ø§Ù†Ú© Ú˜Ø§Ù¾Ù†"
                ]
            }
        ])
        
        # Historical signals (hit take profit)
        signals.extend([
            {
                "id": 4,
                "signal_type": "buy",
                "pair": "AUD/USD",
                "entry_price": 0.6580,
                "stop_loss": 0.6540,
                "take_profit": 0.6650,
                "confidence": 80,
                "status": "hit_tp",
                "created_at": yesterday.isoformat() + "Z",
                "analysis": "Ù‚ÛŒÙ…Øª Ø¨Ø§Ù„Ø§ÛŒ Ú©Ø§Ù…ÙˆØ¯ÛŒØªÛŒâ€ŒÙ‡Ø§",
                "reasons": [
                    "Ø§ÙØ²Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª Ø³Ù†Ú¯ Ø¢Ù‡Ù†",
                    "Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ø´ØªØºØ§Ù„ Ù‚ÙˆÛŒ Ú†ÛŒÙ†",
                    "Ø´Ú©Ø³Øª Ù…Ù‚Ø§ÙˆÙ…Øª"
                ]
            },
            {
                "id": 5,
                "signal_type": "sell",
                "pair": "USD/CAD",
                "entry_price": 1.3480,
                "stop_loss": 1.3530,
                "take_profit": 1.3400,
                "confidence": 70,
                "status": "hit_tp",
                "created_at": yesterday.isoformat() + "Z",
                "analysis": "Ø§ÙØ²Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª Ù†ÙØª Ø¨Ù‡ Ù†ÙØ¹ CAD",
                "reasons": [
                    "Ú©Ø§Ù‡Ø´ Ø°Ø®Ø§ÛŒØ± Ù†ÙØª Ø¢Ù…Ø±ÛŒÚ©Ø§",
                    "ØªÙ†Ø´ Ø¯Ø± Ø®Ø§ÙˆØ±Ù…ÛŒØ§Ù†Ù‡",
                    "ØªØ¶Ø¹ÛŒÙ Ø¯Ù„Ø§Ø±"
                ]
            },
            {
                "id": 6,
                "signal_type": "buy",
                "pair": "EUR/GBP",
                "entry_price": 0.8550,
                "stop_loss": 0.8520,
                "take_profit": 0.8600,
                "confidence": 65,
                "status": "hit_sl",
                "created_at": yesterday.isoformat() + "Z",
                "analysis": "Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§Ø®ØªÙ„Ø§Ù Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡",
                "reasons": [
                    "Ø´ÙˆÚ© Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ù†Ú¯Ù„ÛŒØ³",
                    "Ø´Ú©Ø³Øª Ø­Ù…Ø§ÛŒØª",
                    "Ù†ÙˆØ³Ø§Ù†Ø§Øª Ø´Ø¯ÛŒØ¯"
                ]
            }
        ])
        
        return signals
    
    def _generate_alerts(self) -> List[Dict]:
        """
        Generate sample user alerts for price and news conditions.
        
        Returns:
            List[Dict]: List of alert configurations
        """
        yesterday = self.now - timedelta(days=1)
        
        return [
            {
                "id": 1,
                "name": "Ø´Ú©Ø³Øª Ù…Ù‚Ø§ÙˆÙ…Øª ÛŒÙˆØ±Ùˆ",
                "currency_pair": "EUR/USD",
                "condition_type": "price_above",
                "condition_value": 1.0950,
                "notification_channels": ["web", "telegram"],
                "is_active": True,
                "triggered_at": None,
                "created_at": self.now.isoformat() + "Z",
                "user_id": 1
            },
            {
                "id": 2,
                "name": "Ø­Ù…Ø§ÛŒØª Ø·Ù„Ø§",
                "currency_pair": "XAU/USD",
                "condition_type": "price_below",
                "condition_value": 1980.0,
                "notification_channels": ["web", "email"],
                "is_active": True,
                "triggered_at": None,
                "created_at": self.now.isoformat() + "Z",
                "user_id": 1
            },
            {
                "id": 3,
                "name": "Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯ RSI",
                "currency_pair": "GBP/USD",
                "condition_type": "rsi_above",
                "condition_value": 75.0,
                "notification_channels": ["web"],
                "is_active": False,
                "triggered_at": None,
                "created_at": (self.now - timedelta(days=2)).isoformat() + "Z",
                "user_id": 1
            },
            {
                "id": 4,
                "name": "Ø§Ø®Ø¨Ø§Ø± Ù…Ù‡Ù… Ø¯Ù„Ø§Ø±",
                "currency_pair": "USD/JPY",
                "condition_type": "news_high_impact",
                "condition_value": None,
                "notification_channels": ["web", "telegram", "email"],
                "is_active": True,
                "triggered_at": None,
                "created_at": (self.now - timedelta(days=1)).isoformat() + "Z",
                "user_id": 1
            },
            {
                "id": 5,
                "name": "Ø­Ù…Ø§ÛŒØª GBP",
                "currency_pair": "GBP/USD",
                "condition_type": "price_below",
                "condition_value": 1.2550,
                "notification_channels": ["web"],
                "is_active": True,
                "triggered_at": yesterday.isoformat() + "Z",
                "created_at": (self.now - timedelta(days=5)).isoformat() + "Z",
                "user_id": 1
            },
            {
                "id": 6,
                "name": "Ù…Ù‚Ø§ÙˆÙ…Øª BTC",
                "currency_pair": "BTC/USD",
                "condition_type": "price_above",
                "condition_value": 52000.0,
                "notification_channels": ["telegram"],
                "is_active": False,
                "triggered_at": None,
                "created_at": (self.now - timedelta(days=3)).isoformat() + "Z",
                "user_id": 1
            }
        ]
    
    def _generate_widgets(self) -> List[Dict]:
        """
        Generate available dashboard widgets configuration.
        
        Returns:
            List[Dict]: List of widget configurations
        """
        return [
            {
                "id": "signals",
                "type": "signals",
                "title": "Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ù„Ø­Ø¸Ù‡â€ŒØ§ÛŒ",
                "icon": "Zap",
                "default_order": 0,
                "min_height": 350,
                "config": {
                    "max_signals": 3,
                    "show_confidence": True
                }
            },
            {
                "id": "news",
                "type": "news",
                "title": "Ø§Ø®Ø¨Ø§Ø± Ù…Ù‡Ù…",
                "icon": "Newspaper",
                "default_order": 1,
                "min_height": 300,
                "config": {
                    "max_news": 5,
                    "show_impact": True
                }
            },
            {
                "id": "calendar",
                "type": "calendar",
                "title": "Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ø§Ù…Ø±ÙˆØ²",
                "icon": "Calendar",
                "default_order": 2,
                "min_height": 300,
                "config": {
                    "max_events": 4,
                    "show_high_impact_only": False
                }
            },
            {
                "id": "alerts",
                "type": "alerts",
                "title": "Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ ÙØ¹Ø§Ù„",
                "icon": "Bell",
                "default_order": 3,
                "min_height": 280,
                "config": {
                    "max_alerts": 3,
                    "show_triggered": False
                }
            },
            {
                "id": "chart_eurusd",
                "type": "chart",
                "title": "Ù†Ù…ÙˆØ¯Ø§Ø± EUR/USD",
                "icon": "LineChart",
                "default_order": 4,
                "min_height": 350,
                "config": {
                    "pair": "EUR/USD",
                    "interval": "1h",
                    "indicators": ["MA20", "RSI"]
                }
            },
            {
                "id": "chart_gbpusd",
                "type": "chart",
                "title": "Ù†Ù…ÙˆØ¯Ø§Ø± GBP/USD",
                "icon": "LineChart",
                "default_order": 5,
                "min_height": 350,
                "config": {
                    "pair": "GBP/USD",
                    "interval": "1h",
                    "indicators": ["MA20", "RSI"]
                }
            }
        ]
    
    def _generate_dashboards(self) -> List[Dict]:
        """
        Generate sample user dashboard layouts.
        
        Returns:
            List[Dict]: List of user dashboard configurations
        """
        return [
            {
                "id": 1,
                "user_id": 1,
                "widgets": [
                    {"id": "signals", "order": 0, "config": {"max_signals": 4}},
                    {"id": "news", "order": 1, "config": {}},
                    {"id": "alerts", "order": 2, "config": {}},
                    {"id": "chart_eurusd", "order": 3, "config": {"interval": "4h"}}
                ],
                "created_at": (self.now - timedelta(days=30)).isoformat() + "Z",
                "updated_at": self.now.isoformat() + "Z"
            }
        ]
    
    def generate_chart_data(self, pair: str) -> List[Dict]:
        """
        Generate sample chart data for a currency pair.
        
        Args:
            pair: Currency pair string (e.g., "EUR/USD")
            
        Returns:
            List[Dict]: List of time-price data points
        """
        base_price = 1.0850 if pair == "EUR/USD" else 1.2650
        data = []
        for i in range(24):
            price = base_price + (random.random() - 0.5) * 0.02
            data.append({
                "time": f"{i}:00",
                "price": round(price, 4)
            })
        return data


# ============================================================================
# Initialize Sample Data
# ============================================================================

sample_data = SampleData()


# ============================================================================
# Helper Functions
# ============================================================================

def get_user_from_token(token: str) -> Optional[Dict]:
    """
    Extract and validate user from JWT token.
    
    Args:
        token: JWT token string
        
    Returns:
        Optional[Dict]: User data if token is valid, None otherwise
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = int(payload.get("sub"))
        return next((u for u in sample_data.users if u["id"] == user_id), None)
    except (jwt.ExpiredSignatureError, jwt.InvalidTokenError, ValueError):
        return None


# ============================================================================
# Authentication Endpoints
# ============================================================================

@app.post("/api/auth/login", response_model=LoginResponse)
async def login(request: LoginRequest):
    """
    Authenticate user and return JWT token.
    
    Args:
        request: Login credentials
        
    Returns:
        LoginResponse: JWT token and user data
        
    Raises:
        HTTPException: 401 if credentials invalid, 403 if account inactive
    """
    user = next((u for u in sample_data.users if u["email"] == request.email), None)
    
    if not user or user["password"] != request.password:
        raise HTTPException(status_code=401, detail="Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª")
    
    if not user["is_active"]:
        raise HTTPException(status_code=403, detail="Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª")
    
    # Generate JWT token
    token_data = {
        "sub": str(user["id"]),
        "email": user["email"],
        "role": user["role"],
        "exp": datetime.utcnow() + timedelta(days=7)
    }
    
    token = jwt.encode(token_data, SECRET_KEY, algorithm=ALGORITHM)
    
    # Remove password from response
    user_response = {k: v for k, v in user.items() if k != "password"}
    
    return LoginResponse(
        token=token,
        user=user_response,
        message="ÙˆØ±ÙˆØ¯ Ù…ÙˆÙÙ‚ÛŒØªâ€ŒØ¢Ù…ÛŒØ² Ø¨ÙˆØ¯"
    )


@app.get("/api/auth/me")
async def get_current_user(token: str):
    """
    Get current user information from token.
    
    Args:
        token: JWT token
        
    Returns:
        Dict: User data without password
        
    Raises:
        HTTPException: 401 if token invalid, 404 if user not found
    """
    user = get_user_from_token(token)
    
    if not user:
        raise HTTPException(status_code=401, detail="ØªÙˆÚ©Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª")
    
    return {k: v for k, v in user.items() if k != "password"}


@app.post("/api/auth/register")
async def register(user_data: dict):
    """
    Register a new user account.
    
    Args:
        user_data: New user information (email, password, name)
        
    Returns:
        Dict: JWT token and user data
        
    Raises:
        HTTPException: 400 if email already exists
    """
    if any(u["email"] == user_data["email"] for u in sample_data.users):
        raise HTTPException(status_code=400, detail="Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ù‚Ø¨Ù„Ø§Ù‹ Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø§Ø³Øª")
    
    # Create new user
    new_user = {
        "id": len(sample_data.users) + 1,
        "email": user_data["email"],
        "password": user_data["password"],  # In production, hash this
        "name": user_data.get("name", user_data["email"].split('@')[0]),
        "role": "demo",
        "is_active": True,
        "created_at": datetime.utcnow().isoformat() + "Z"
    }
    
    sample_data.users.append(new_user)
    
    # Generate token
    token_data = {
        "sub": str(new_user["id"]),
        "email": new_user["email"],
        "role": new_user["role"],
        "exp": datetime.utcnow() + timedelta(days=7)
    }
    
    token = jwt.encode(token_data, SECRET_KEY, algorithm=ALGORITHM)
    
    user_response = {k: v for k, v in new_user.items() if k != "password"}
    
    return {
        "token": token,
        "user": user_response,
        "message": "Ø«Ø¨Øª Ù†Ø§Ù… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯"
    }


@app.post("/api/auth/logout")
async def logout():
    """
    Logout user (client-side token removal).
    
    Returns:
        Dict: Success message
    """
    return {"message": "Ø®Ø±ÙˆØ¬ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯"}


# ============================================================================
# News Endpoints
# ============================================================================

@app.get("/api/news/config")
async def get_news_config():
    """
    Get configuration for news page UI.
    
    Returns:
        Dict: UI configuration with labels and filters
    """
    return {
        "pageTitle": "Ø§Ø®Ø¨Ø§Ø± Ùˆ ØªØ­Ù„ÛŒÙ„ Ø¨Ø§Ø²Ø§Ø±",
        "pageSubtitle": "ØªØ­Ù„ÛŒÙ„ Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø§Ø®Ø¨Ø§Ø± ÙØ§Ø±Ú©Ø³ Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ - Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø¬Ù‡Øª Ø¨Ø§Ø²Ø§Ø±",
        "searchPlaceholder": "Ø¬Ø³ØªØ¬Ùˆ Ø¯Ø± Ø§Ø®Ø¨Ø§Ø±...",
        "refreshButton": "Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ",
        "emptyTitle": "Ø®Ø¨Ø±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯",
        "emptySubtitle": "ÙÛŒÙ„ØªØ±Ù‡Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡ÛŒØ¯",
        "predictionsTitle": "Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±",
        "impactFilters": [
            {"value": "all", "label": "Ù‡Ù…Ù‡"},
            {"value": "high", "label": "ØªØ£Ø«ÛŒØ± Ø¨Ø§Ù„Ø§"},
            {"value": "medium", "label": "ØªØ£Ø«ÛŒØ± Ù…ØªÙˆØ³Ø·"},
            {"value": "low", "label": "ØªØ£Ø«ÛŒØ± Ú©Ù…"}
        ]
    }


@app.get("/api/news/filters")
async def get_news_filters():
    """
    Get available filters for news page.
    
    Returns:
        Dict: Filter options for impact, sentiment, and prediction
    """
    return {
        "impact": [
            {"value": "all", "label": "Ù‡Ù…Ù‡"},
            {"value": "high", "label": "ØªØ£Ø«ÛŒØ± Ø¨Ø§Ù„Ø§"},
            {"value": "medium", "label": "ØªØ£Ø«ÛŒØ± Ù…ØªÙˆØ³Ø·"},
            {"value": "low", "label": "ØªØ£Ø«ÛŒØ± Ú©Ù…"}
        ],
        "sentiment": [
            {"value": "all", "label": "Ù‡Ù…Ù‡"},
            {"value": "positive", "label": "ğŸ˜Š Ù…Ø«Ø¨Øª"},
            {"value": "neutral", "label": "ğŸ˜ Ø®Ù†Ø«ÛŒ"},
            {"value": "negative", "label": "ğŸ˜Ÿ Ù…Ù†ÙÛŒ"}
        ],
        "prediction": [
            {"value": "all", "label": "Ù‡Ù…Ù‡"},
            {"value": "bullish", "label": "ğŸ‚ ØµØ¹ÙˆØ¯ÛŒ"},
            {"value": "bearish", "label": "ğŸ» Ù†Ø²ÙˆÙ„ÛŒ"},
            {"value": "neutral", "label": "âš–ï¸ Ø®Ù†Ø«ÛŒ"}
        ]
    }


@app.get("/api/news", response_model=List[NewsArticle])
async def get_news(
    search: Optional[str] = None,
    impact: Optional[str] = None,
    sentiment: Optional[str] = None,
    prediction: Optional[str] = None,
    currency: Optional[str] = None,
    limit: int = 50
):
    """
    Get filtered news articles.
    
    Args:
        search: Text to search in title and summary
        impact: Filter by impact level (high, medium, low)
        sentiment: Filter by sentiment (positive, neutral, negative)
        prediction: Filter by prediction direction (bullish, bearish, neutral)
        currency: Filter by affected currency
        limit: Maximum number of articles to return
        
    Returns:
        List[NewsArticle]: Filtered news articles
    """
    filtered_news = sample_data.news.copy()
    
    if search:
        search_lower = search.lower()
        filtered_news = [
            item for item in filtered_news 
            if search_lower in item["title"].lower() 
            or search_lower in item["summary"].lower()
        ]
    
    if impact and impact != "all":
        filtered_news = [item for item in filtered_news if item["impact_level"] == impact]
    
    if sentiment and sentiment != "all":
        filtered_news = [item for item in filtered_news if item["sentiment"] == sentiment]
    
    if prediction and prediction != "all":
        if prediction == "bullish":
            filtered_news = [item for item in filtered_news if "bullish" in item["prediction"].lower()]
        elif prediction == "bearish":
            filtered_news = [item for item in filtered_news if "bearish" in item["prediction"].lower()]
        elif prediction == "neutral":
            filtered_news = [item for item in filtered_news if "neutral" in item["prediction"].lower()]
    
    if currency and currency != "all":
        filtered_news = [item for item in filtered_news if currency in item["affected_currencies"]]
    
    return filtered_news[:limit]


@app.get("/api/news/{news_id}")
async def get_news_by_id(news_id: int):
    """
    Get a specific news article by ID.
    
    Args:
        news_id: Article ID
        
    Returns:
        Dict: News article data
        
    Raises:
        HTTPException: 404 if article not found
    """
    for news in sample_data.news:
        if news["id"] == news_id:
            return news
    raise HTTPException(status_code=404, detail="Ø®Ø¨Ø± Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯")


# ============================================================================
# Economic Calendar Endpoints
# ============================================================================

@app.get("/api/calendar/config")
async def get_calendar_config():
    """
    Get configuration for economic calendar page UI.
    
    Returns:
        Dict: UI configuration with labels and filters
    """
    return {
        "pageTitle": "ØªÙ‚ÙˆÛŒÙ… Ø§Ù‚ØªØµØ§Ø¯ÛŒ",
        "pageSubtitle": "Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ù…Ù‡Ù… Ø§Ù‚ØªØµØ§Ø¯ÛŒ Ùˆ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ù†ÙˆØ³Ø§Ù†Ø§Øª",
        "refreshButton": "Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ",
        "emptyTitle": "Ø±ÙˆÛŒØ¯Ø§Ø¯ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯",
        "emptySubtitle": "ÙÛŒÙ„ØªØ±Ù‡Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡ÛŒØ¯",
        "upcomingAlertTitle": "Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ù¾Ø±Ø§Ù‡Ù…ÛŒØª Ù¾ÛŒØ´ Ø±Ùˆ",
        "tableHeaders": {
            "time": "Ø²Ù…Ø§Ù†",
            "country": "Ú©Ø´ÙˆØ±",
            "event": "Ø±ÙˆÛŒØ¯Ø§Ø¯",
            "importance": "Ø§Ù‡Ù…ÛŒØª",
            "forecast": "Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ",
            "previous": "Ù‚Ø¨Ù„ÛŒ",
            "actual": "ÙˆØ§Ù‚Ø¹ÛŒ",
        },
    }


@app.get("/api/calendar/filters")
async def get_calendar_filters():
    """
    Get available filters for calendar page.
    
    Returns:
        Dict: Filter options for time, importance, and countries
    """
    return {
        "time": [
            {"value": "today", "label": "Ø§Ù…Ø±ÙˆØ²"},
            {"value": "week", "label": "Ø§ÛŒÙ† Ù‡ÙØªÙ‡"},
            {"value": "all", "label": "Ù‡Ù…Ù‡"},
        ],
        "importance": [
            {"value": "all", "label": "Ù‡Ù…Ù‡"},
            {"value": "high", "label": "Ø²ÛŒØ§Ø¯"},
            {"value": "medium", "label": "Ù…ØªÙˆØ³Ø·"},
            {"value": "low", "label": "Ú©Ù…"},
        ],
        "countries": ['Ù‡Ù…Ù‡', 'USD', 'EUR', 'GBP', 'JPY', 'AUD', 'CAD', 'CHF', 'NZD'],
    }


@app.get("/api/calendar/events")
async def get_events(
    time_filter: Optional[str] = "all",
    importance: Optional[str] = "all",
    country: Optional[str] = "all",
    limit: int = 100
):
    """
    Get filtered economic events.
    
    Args:
        time_filter: Filter by time (today, week, all)
        importance: Filter by importance (high, medium, low)
        country: Filter by country code
        limit: Maximum number of events to return
        
    Returns:
        List[Dict]: Filtered economic events
    """
    filtered_events = sample_data.events.copy()
    
    # Time filter
    if time_filter and time_filter != "all":
        now = datetime.now()
        
        if time_filter == "today":
            today = now.date()
            filtered_events = [
                e for e in filtered_events 
                if datetime.fromisoformat(e["event_time"].replace('Z', '+00:00')).date() == today
            ]
        elif time_filter == "week":
            start_of_week = now - timedelta(days=now.weekday())
            end_of_week = start_of_week + timedelta(days=6)
            filtered_events = [
                e for e in filtered_events 
                if start_of_week.date() <= datetime.fromisoformat(e["event_time"].replace('Z', '+00:00')).date() <= end_of_week.date()
            ]
    
    # Importance filter
    if importance and importance != "all":
        filtered_events = [e for e in filtered_events if e["importance"] == importance]
    
    # Country filter
    if country and country != "all":
        filtered_events = [e for e in filtered_events if e["country"] == country]
    
    return filtered_events[:limit]


# ============================================================================
# Trading Signals Endpoints
# ============================================================================

@app.get("/api/signals/config")
async def get_signals_config():
    """
    Get configuration for trading signals page UI.
    
    Returns:
        Dict: UI configuration with labels and filters
    """
    return {
        "pageTitle": "Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ AI",
        "pageSubtitle": "Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø¨Ø± Ø§Ø³Ø§Ø³ ØªØ­Ù„ÛŒÙ„ Ø§Ø®Ø¨Ø§Ø±ØŒ ØªÙ‚ÙˆÛŒÙ… Ùˆ ØªÚ©Ù†ÛŒÚ©Ø§Ù„",
        "refreshButton": "Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ",
        "emptyTitle": "Ø³ÛŒÚ¯Ù†Ø§Ù„ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯",
        "emptySubtitle": "ÙÛŒÙ„ØªØ±Ù‡Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡ÛŒØ¯",
        "proBadge": "ÙˆÛŒÚ˜Ù‡ Ù¾Ù„Ù† Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ",
        "statusFilters": [
            {"value": "all", "label": "Ù‡Ù…Ù‡"},
            {"value": "active", "label": "ÙØ¹Ø§Ù„"},
            {"value": "hit_tp", "label": "Ø³ÙˆØ¯"},
            {"value": "hit_sl", "label": "Ø¶Ø±Ø±"}
        ],
        "typeFilters": [
            {"value": "all", "label": "Ù‡Ù…Ù‡"},
            {"value": "buy", "label": "Ø®Ø±ÛŒØ¯"},
            {"value": "sell", "label": "ÙØ±ÙˆØ´"}
        ]
    }


@app.get("/api/signals")
async def get_signals(
    status: Optional[str] = None,
    signal_type: Optional[str] = None,
    pair: Optional[str] = None,
    limit: int = 50
):
    """
    Get filtered trading signals.
    
    Args:
        status: Filter by status (active, hit_tp, hit_sl)
        signal_type: Filter by type (buy, sell)
        pair: Filter by currency pair
        limit: Maximum number of signals to return
        
    Returns:
        List[Dict]: Filtered trading signals
    """
    filtered_signals = sample_data.signals.copy()
    
    if status and status != "all":
        filtered_signals = [s for s in filtered_signals if s["status"] == status]
    
    if signal_type and signal_type != "all":
        filtered_signals = [s for s in filtered_signals if s["signal_type"] == signal_type]
    
    if pair and pair != "all":
        filtered_signals = [s for s in filtered_signals if pair.lower() in s["pair"].lower()]
    
    return filtered_signals[:limit]


@app.get("/api/signals/{signal_id}")
async def get_signal_by_id(signal_id: int):
    """
    Get a specific trading signal by ID.
    
    Args:
        signal_id: Signal ID
        
    Returns:
        Dict: Trading signal data
        
    Raises:
        HTTPException: 404 if signal not found
    """
    for signal in sample_data.signals:
        if signal["id"] == signal_id:
            return signal
    raise HTTPException(status_code=404, detail="Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯")


@app.get("/api/signals/stats")
async def get_signals_stats():
    """
    Get statistics about trading signals.
    
    Returns:
        Dict: Signal statistics including counts and success rate
    """
    total = len(sample_data.signals)
    active = len([s for s in sample_data.signals if s["status"] == "active"])
    hit_tp = len([s for s in sample_data.signals if s["status"] == "hit_tp"])
    hit_sl = len([s for s in sample_data.signals if s["status"] == "hit_sl"])
    buy = len([s for s in sample_data.signals if s["signal_type"] == "buy"])
    sell = len([s for s in sample_data.signals if s["signal_type"] == "sell"])
    
    # Success rate (hit TP / closed signals)
    closed = hit_tp + hit_sl
    success_rate = (hit_tp / closed * 100) if closed > 0 else 0
    
    return {
        "total": total,
        "active": active,
        "hit_tp": hit_tp,
        "hit_sl": hit_sl,
        "buy": buy,
        "sell": sell,
        "success_rate": round(success_rate, 1)
    }


# ============================================================================
# Alerts Endpoints
# ============================================================================

@app.get("/api/alerts/config")
async def get_alerts_config():
    """
    Get configuration for alerts page UI.
    
    Returns:
        Dict: UI configuration with labels and filters
    """
    return {
        "pageTitle": "Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯",
        "pageSubtitle": "Ø¯Ø±ÛŒØ§ÙØª Ø§Ø¹Ù„Ø§Ù† Ø¨Ø±Ø§ÛŒ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ù…Ù‡Ù… Ø¨Ø§Ø²Ø§Ø±",
        "newAlertButton": "Ù‡Ø´Ø¯Ø§Ø± Ø¬Ø¯ÛŒØ¯",
        "createFirstButton": "Ø§ÛŒØ¬Ø§Ø¯ Ø§ÙˆÙ„ÛŒÙ† Ù‡Ø´Ø¯Ø§Ø±",
        "emptyTitle": "Ù‡Ø´Ø¯Ø§Ø±ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯",
        "emptySubtitle": "Ø¨Ø§ Ø§ÛŒØ¬Ø§Ø¯ Ù‡Ø´Ø¯Ø§Ø±ØŒ Ø§Ø² Ù†ÙˆØ³Ø§Ù†Ø§Øª Ù…Ù‡Ù… Ø¨Ø§Ø²Ø§Ø± Ù…Ø·Ù„Ø¹ Ø´ÙˆÛŒØ¯",
        "activeAlertsTitle": "Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ ÙØ¹Ø§Ù„",
        "inactiveAlertsTitle": "Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ ØºÛŒØ±ÙØ¹Ø§Ù„",
        "stats": {
            "total": "Ù…Ø¬Ù…ÙˆØ¹ Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§",
            "active": "ÙØ¹Ø§Ù„",
            "inactive": "ØºÛŒØ±ÙØ¹Ø§Ù„",
            "triggered": "Ø´Ù„ÛŒÚ© Ø´Ø¯Ù‡"
        },
        "conditionLabels": {
            "price_above": "Ù‚ÛŒÙ…Øª Ø¨Ø§Ù„Ø§ØªØ± Ø§Ø²",
            "price_below": "Ù‚ÛŒÙ…Øª Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø²",
            "rsi_above": "RSI Ø¨Ø§Ù„Ø§ØªØ± Ø§Ø²",
            "rsi_below": "RSI Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø²",
            "news_high_impact": "Ø®Ø¨Ø± Ø¨Ø§ ØªØ£Ø«ÛŒØ± Ø¨Ø§Ù„Ø§"
        }
    }


@app.get("/api/alerts")
async def get_alerts(
    is_active: Optional[bool] = None,
    currency_pair: Optional[str] = None,
    user_id: int = 1,
    limit: int = 50
):
    """
    Get user alerts with optional filters.
    
    Args:
        is_active: Filter by active status
        currency_pair: Filter by currency pair
        user_id: User ID (default: 1 for demo)
        limit: Maximum number of alerts to return
        
    Returns:
        List[Dict]: Filtered alerts
    """
    filtered_alerts = [a for a in sample_data.alerts if a["user_id"] == user_id]
    
    if is_active is not None:
        filtered_alerts = [a for a in filtered_alerts if a["is_active"] == is_active]
    
    if currency_pair and currency_pair != "all":
        filtered_alerts = [a for a in filtered_alerts if currency_pair.lower() in a["currency_pair"].lower()]
    
    return filtered_alerts[:limit]


@app.get("/api/alerts/{alert_id}")
async def get_alert_by_id(alert_id: int):
    """
    Get a specific alert by ID.
    
    Args:
        alert_id: Alert ID
        
    Returns:
        Dict: Alert data
        
    Raises:
        HTTPException: 404 if alert not found
    """
    for alert in sample_data.alerts:
        if alert["id"] == alert_id:
            return alert
    raise HTTPException(status_code=404, detail="Ù‡Ø´Ø¯Ø§Ø± Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯")


@app.post("/api/alerts")
async def create_alert(alert: dict):
    """
    Create a new alert.
    
    Args:
        alert: Alert configuration data
        
    Returns:
        Dict: Created alert with ID and timestamps
    """
    new_id = max([a["id"] for a in sample_data.alerts]) + 1
    new_alert = {
        "id": new_id,
        **alert,
        "created_at": datetime.now().isoformat() + "Z",
        "triggered_at": None,
        "user_id": 1  # Default for demo
    }
    sample_data.alerts.append(new_alert)
    return new_alert


@app.put("/api/alerts/{alert_id}")
async def update_alert(alert_id: int, alert_data: dict):
    """
    Update an existing alert.
    
    Args:
        alert_id: Alert ID
        alert_data: Updated alert data
        
    Returns:
        Dict: Updated alert
        
    Raises:
        HTTPException: 404 if alert not found
    """
    for i, alert in enumerate(sample_data.alerts):
        if alert["id"] == alert_id:
            sample_data.alerts[i].update(alert_data)
            return sample_data.alerts[i]
    raise HTTPException(status_code=404, detail="Ù‡Ø´Ø¯Ø§Ø± Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯")


@app.delete("/api/alerts/{alert_id}")
async def delete_alert(alert_id: int):
    """
    Delete an alert.
    
    Args:
        alert_id: Alert ID
        
    Returns:
        Dict: Deleted alert
        
    Raises:
        HTTPException: 404 if alert not found
    """
    for i, alert in enumerate(sample_data.alerts):
        if alert["id"] == alert_id:
            return sample_data.alerts.pop(i)
    raise HTTPException(status_code=404, detail="Ù‡Ø´Ø¯Ø§Ø± Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯")


@app.get("/api/alerts/stats")
async def get_alerts_stats(user_id: int = 1):
    """
    Get statistics about user alerts.
    
    Args:
        user_id: User ID (default: 1 for demo)
        
    Returns:
        Dict: Alert statistics
    """
    user_alerts = [a for a in sample_data.alerts if a["user_id"] == user_id]
    total = len(user_alerts)
    active = len([a for a in user_alerts if a["is_active"]])
    inactive = len([a for a in user_alerts if not a["is_active"]])
    triggered = len([a for a in user_alerts if a["triggered_at"] is not None])
    
    return {
        "total": total,
        "active": active,
        "inactive": inactive,
        "triggered": triggered
    }


@app.get("/api/alerts/conditions")
async def get_alert_conditions():
    """
    Get available conditions for creating alerts.
    
    Returns:
        Dict: Available currency pairs, condition types, and notification channels
    """
    return {
        "currency_pairs": ["EUR/USD", "GBP/USD", "USD/JPY", "XAU/USD", "USD/CHF", "AUD/USD", "BTC/USD", "NZD/USD", "USD/CAD"],
        "condition_types": [
            {"value": "price_above", "label": "Ù‚ÛŒÙ…Øª Ø¨Ø§Ù„Ø§ØªØ± Ø§Ø²", "has_value": True},
            {"value": "price_below", "label": "Ù‚ÛŒÙ…Øª Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø²", "has_value": True},
            {"value": "rsi_above", "label": "RSI Ø¨Ø§Ù„Ø§ØªØ± Ø§Ø²", "has_value": True},
            {"value": "rsi_below", "label": "RSI Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø²", "has_value": True},
            {"value": "news_high_impact", "label": "Ø®Ø¨Ø± Ø¨Ø§ ØªØ£Ø«ÛŒØ± Ø¨Ø§Ù„Ø§", "has_value": False}
        ],
        "notification_channels": [
            {"value": "web", "label": "ÙˆØ¨", "icon": "Globe"},
            {"value": "telegram", "label": "ØªÙ„Ú¯Ø±Ø§Ù…", "icon": "MessageCircle"},
            {"value": "email", "label": "Ø§ÛŒÙ…ÛŒÙ„", "icon": "Mail"}
        ]
    }


# ============================================================================
# Dashboard Endpoints
# ============================================================================

@app.get("/api/dashboard/config")
async def get_dashboard_config():
    """
    Get configuration for dashboard page UI.
    
    Returns:
        Dict: UI configuration with labels and buttons
    """
    return {
        "pageTitle": "Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ",
        "pageSubtitle": "Ù†Ù…Ø§ÛŒØ´ Ø®Ù„Ø§ØµÙ‡â€ŒØ§ÛŒ Ø§Ø² ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø²Ø§Ø±ØŒ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ Ùˆ Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§",
        "editButton": "ÙˆÛŒØ±Ø§ÛŒØ´ Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯",
        "saveButton": "Ø°Ø®ÛŒØ±Ù‡ ØªØºÛŒÛŒØ±Ø§Øª",
        "cancelButton": "Ø§Ù†ØµØ±Ø§Ù",
        "widgetSelectorLabel": "ÙˆÛŒØ¬Øªâ€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯",
        "emptyTitle": "Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ø´Ù…Ø§ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª",
        "emptySubtitle": "Ø¨Ø§ Ø§ÙØ²ÙˆØ¯Ù† ÙˆÛŒØ¬Øªâ€ŒÙ‡Ø§ØŒ Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ø®ÙˆØ¯ Ø±Ø§ Ø´Ø®ØµÛŒâ€ŒØ³Ø§Ø²ÛŒ Ú©Ù†ÛŒØ¯",
        "addWidgetButton": "Ø§ÙØ²ÙˆØ¯Ù† ÙˆÛŒØ¬Øª"
    }


@app.get("/api/dashboard/widgets")
async def get_available_widgets():
    """
    Get all available dashboard widgets.
    
    Returns:
        List[Dict]: Available widget configurations
    """
    return sample_data.widgets


@app.get("/api/dashboard/defaults")
async def get_default_widgets():
    """
    Get default widget IDs in recommended order.
    
    Returns:
        List[str]: List of default widget IDs
    """
    default_order = sorted(sample_data.widgets, key=lambda x: x["default_order"])
    return [w["id"] for w in default_order[:4]]  # First 4 widgets


@app.get("/api/dashboard/user/{user_id}")
async def get_user_dashboard(user_id: int = 1):
    """
    Get user's dashboard configuration.
    
    Args:
        user_id: User ID (default: 1 for demo)
        
    Returns:
        Dict: User dashboard configuration
    """
    for dashboard in sample_data.dashboards:
        if dashboard["user_id"] == user_id:
            return dashboard
    
    # Return default dashboard if none exists
    return {
        "id": None,
        "user_id": user_id,
        "widgets": [
            {"id": w["id"], "order": i, "config": {}}
            for i, w in enumerate(sample_data.widgets[:4])
        ],
        "created_at": datetime.now().isoformat() + "Z",
        "updated_at": datetime.now().isoformat() + "Z"
    }


@app.post("/api/dashboard/user/{user_id}")
async def save_user_dashboard(user_id: int, dashboard_data: dict):
    """
    Save or update user's dashboard configuration.
    
    Args:
        user_id: User ID
        dashboard_data: Dashboard configuration
        
    Returns:
        Dict: Saved dashboard configuration
    """
    # Update existing dashboard
    for i, dashboard in enumerate(sample_data.dashboards):
        if dashboard["user_id"] == user_id:
            sample_data.dashboards[i].update({
                "widgets": dashboard_data.get("widgets", []),
                "updated_at": datetime.now().isoformat() + "Z"
            })
            return sample_data.dashboards[i]
    
    # Create new dashboard
    new_dashboard = {
        "id": len(sample_data.dashboards) + 1,
        "user_id": user_id,
        "widgets": dashboard_data.get("widgets", []),
        "created_at": datetime.now().isoformat() + "Z",
        "updated_at": datetime.now().isoformat() + "Z"
    }
    sample_data.dashboards.append(new_dashboard)
    return new_dashboard


@app.get("/api/dashboard/widgets/{widget_id}/data")
async def get_widget_data(widget_id: str):
    """
    Get data for a specific dashboard widget.
    
    Args:
        widget_id: Widget identifier
        
    Returns:
        Dict: Widget-specific data
        
    Raises:
        HTTPException: 404 if widget not found
    """
    widget = next((w for w in sample_data.widgets if w["id"] == widget_id), None)
    
    if not widget:
        raise HTTPException(status_code=404, detail="ÙˆÛŒØ¬Øª Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯")
    
    # Return data based on widget type
    if widget["type"] == "signals":
        active_signals = [s for s in sample_data.signals if s["status"] == "active"][:3]
        return {
            "signals": active_signals,
            "total_active": len([s for s in sample_data.signals if s["status"] == "active"])
        }
    
    elif widget["type"] == "news":
        important_news = [n for n in sample_data.news if n["impact_level"] in ["high", "medium"]][:5]
        return {
            "news": important_news,
            "total": len(sample_data.news)
        }
    
    elif widget["type"] == "calendar":
        today = datetime.now().date()
        today_events = [
            e for e in sample_data.events 
            if datetime.fromisoformat(e["event_time"].replace('Z', '+00:00')).date() == today
        ][:4]
        return {
            "events": today_events,
            "total_today": len(today_events)
        }
    
    elif widget["type"] == "alerts":
        active_alerts = [a for a in sample_data.alerts if a["is_active"]][:3]
        return {
            "alerts": active_alerts,
            "total_active": len([a for a in sample_data.alerts if a["is_active"]])
        }
    
    elif widget["type"] == "chart":
        pair = widget["config"]["pair"]
        return {
            "pair": pair,
            "current_price": 1.0850 if pair == "EUR/USD" else 1.2650,
            "change_24h": 0.15 if pair == "EUR/USD" else -0.22,
            "chart_data": sample_data.generate_chart_data(pair)
        }
    
    return {}


@app.get("/api/dashboard/stats")
async def get_dashboard_stats():
    """
    Get overall statistics for dashboard display.
    
    Returns:
        Dict: Summary statistics for dashboard
    """
    active_signals = len([s for s in sample_data.signals if s["status"] == "active"])
    today_events = len([
        e for e in sample_data.events 
        if datetime.fromisoformat(e["event_time"].replace('Z', '+00:00')).date() == datetime.now().date()
    ])
    active_alerts = len([a for a in sample_data.alerts if a["is_active"]])
    important_news = len([n for n in sample_data.news if n["impact_level"] == "high"])
    
    return {
        "active_signals": active_signals,
        "today_events": today_events,
        "active_alerts": active_alerts,
        "important_news": important_news
    }


# ============================================================================
# Main Entry Point
# ============================================================================

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)